module Test.Framework.ThreadPool (
        executeOnPool
    ) where

import Control.Concurrent
import Control.Concurrent.Chan
import Control.Monad

import qualified Data.IntMap as IM

executeOnPool :: Int    -- ^ Number of threads to use
              -> [IO a] -- ^ Actions to execute, left to right as far possible
              -> IO [a] -- ^ Ordered results of executing the given IO actions in parallel
executeOnPool n actions = do
    -- Prepare the channels
    input_chan <- newChan
    output_chan <- newChan
    
    -- Write Just the actions to the channel followed by one Nothing per thread
    -- that indicates they should terminate. We do this on another thread for
    -- maximum laziness (in case one the actions we are going to run depend on the
    -- output from previous actions..)
    forkIO $ writeList2Chan input_chan (map Just ([0..] `zip` actions) ++ replicate n Nothing)
    
    -- Spawn workers
    forM_ [1..n] (const $ forkIO $ poolWorker input_chan output_chan)
    
    -- Return the results generated by the worker threads lazily and in
    -- the same order as we got the inputs
    fmap (reorderFrom 0) $ getChanContents output_chan

poolWorker :: Chan (Maybe (token, IO a)) -> Chan (token, a) -> IO ()
poolWorker input_chan output_chan = do
    -- Read an action and work out whether we should continue or stop
    mb_action <- readChan input_chan
    case mb_action of
        Nothing -> return () -- Must have run out of real actions to execute
        Just (token, action) -> do
            -- Do the action then loop
            result <- action
            writeChan output_chan (token, result)
            poolWorker input_chan output_chan

reorderFrom :: Int -> [(Int, a)] -> [a]
reorderFrom from initial_things = go from initial_things IM.empty False
  where go next [] buf _
          | IM.null buf = []    -- If the buffer and input list is empty, we're done
          | otherwise   = go next (IM.toList buf) IM.empty False    -- Make sure we check the buffer even if the list is done
        go next all_things@((token, x):things) buf buf_useful
          | token == next                       -- If the list token matches the one we were expecting we can just take the item
          = x : go (next + 1) things buf True   -- Always worth checking the buffer now because the expected item has changed
          | buf_useful                                                              -- If it's worth checking the buffer, it's possible the token we need is in it
          , (Just x', buf') <- IM.updateLookupWithKey (const $ const Nothing) next buf  -- Delete the found item from the map (if we find it) to save space
          = x' : go (next + 1) all_things buf' True                                     -- Always worth checking the buffer now because the expected item has changed
          | otherwise                                       -- Token didn't match, buffer unhelpful: it must be in the tail of the list
          = go next things (IM.insert token x buf) False    -- Since we've already checked the buffer, stop bothering to do so until something changes